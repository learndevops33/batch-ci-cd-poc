name: mock CI/CD

on:
  workflow_dispatch: 
  push:
    branches:
      - 'feature/*'
      - 'develop'
      - 'release/*'
      - 'main'
    paths:
      - alpha/**
      - beta/**
      - gamma/**
  pull_request:
    branches:
      - 'release/*'
      - develop
      - main

jobs:
  rebase:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    steps:
      - name: Checkout the target branch (base)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}  # Target branch like develop
          fetch-depth: 0
          clean: true

      - name: Checkout the current branch (head)
        run: |
          git fetch origin ${{ github.event.pull_request.head.ref }}  # Fetch the feature branch
          git checkout ${{ github.event.pull_request.head.ref }}      # Checkout the feature branch

      - name: Rebase the current branch onto the target branch
        run: |
          git rebase origin/${{ github.event.pull_request.base.ref }}  # Rebase the feature branch onto develop

      - name: Push the rebased branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Use GitHub token to push
        run: |
          git push origin ${{ github.event.pull_request.head.ref }} --force  # Force push after rebase to update the PR

  build:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    outputs:
      alpha_exists: ${{ steps.set_programs.outputs.alpha_exists }}
      beta_exists: ${{ steps.set_programs.outputs.beta_exists }}
      gamma_exists: ${{ steps.set_programs.outputs.gamma_exists }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set environment based on the branch or PR
        id: set_env
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BRANCH="${{ github.event.pull_request.base.ref }}"
          else
            BRANCH="${{ github.ref_name }}"
          fi

          if [[ "$BRANCH" == feature/* || "$BRANCH" == bugfix/* ]]; then
            ENVIRONMENT="dev"
          elif [[ "$BRANCH" == release/* || "$BRANCH" == develop ]]; then
            ENVIRONMENT="uat"
          elif [[ "$BRANCH" == main || "$BRANCH" == hotfix/* ]]; then
            ENVIRONMENT="prod"
          else
            echo "Unknown branch, exiting"
            exit 1
          fi

          echo "environment is set to $ENVIRONMENT"
          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
          echo "BRANCH=$BRANCH" >> $GITHUB_ENV

          # GitHub summary for this step
          echo "### Environment and Branch Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: $BRANCH" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY

      - name: Determine base branch based on current branch
        run: |
          git fetch --all
          
          # GitHub event type logging
          echo "**GitHub Event :** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          
          # Determine base branch based on the event type
          if [[ "${{ github.event_name }}" == "pull_request" && "$BRANCH" == develop ]]; then
            echo "**GitHub Event :** pull_request" >> $GITHUB_STEP_SUMMARY
            BASE_BRANCH="develop"
          elif [[ "${{ github.event_name }}" == "pull_request" && "$BRANCH" == main ]]; then
            echo "**GitHub Event :** pull_request" >> $GITHUB_STEP_SUMMARY
            BASE_BRANCH="main"
          elif [[ "$BRANCH" == feature/* ]]; then
            echo "Feature branch detected" >> $GITHUB_STEP_SUMMARY
            BASE_BRANCH="develop"
          elif [[ "$BRANCH" == develop ]]; then
            echo "develop branch detected" >> $GITHUB_STEP_SUMMARY
            BASE_BRANCH="main"
          else
            BASE_BRANCH="main"
          fi
      
          echo "Base branch is determined as: $BASE_BRANCH" >> $GITHUB_STEP_SUMMARY
          echo "BASE_BRANCH=$BASE_BRANCH" >> $GITHUB_ENV
          
          # Verify the BASE_BRANCH exists after fetching
          if git show-ref --verify --quiet refs/remotes/origin/$BASE_BRANCH; then
            echo "Base branch exists remotely."
          else
            echo "Base branch does not exist remotely. Exiting."
            exit 1
          fi
          
          # Get the current branch dynamically based on the event
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CURRENT_BRANCH="${{ github.event.pull_request.head.ref }}"
          else
            CURRENT_BRANCH="${{ github.ref_name }}"
          fi
          
          echo "Current branch is: $CURRENT_BRANCH" >> $GITHUB_STEP_SUMMARY
      
          # Fetch the current branch if not already available
          git fetch origin $CURRENT_BRANCH
          
          # Display git rev-parse for base branch and current commit
          BASE_BRANCH_SHA=$(git rev-parse origin/$BASE_BRANCH)
          CURRENT_SHA="${{ github.sha }}"
          
          echo "Base branch ($BASE_BRANCH) commit hash: $BASE_BRANCH_SHA"
          echo "Current commit hash (github.sha): $CURRENT_SHA"
          
          # Log branch and commit information
          echo "### Branch & Commit Hashes" >> $GITHUB_STEP_SUMMARY
          echo "- **Base branch**: $BASE_BRANCH" >> $GITHUB_STEP_SUMMARY
          echo "- **Current branch**: $CURRENT_BRANCH" >> $GITHUB_STEP_SUMMARY
          echo "- **Base branch commit ($BASE_BRANCH)**: $BASE_BRANCH_SHA" >> $GITHUB_STEP_SUMMARY
          echo "- **Current branch commit (github.sha)**: $CURRENT_SHA" >> $GITHUB_STEP_SUMMARY
          
          # Check if PR is merged by comparing base and current branch commits
          if [[ "$BASE_BRANCH_SHA" == "$CURRENT_SHA" ]]; then
            echo "$BASE_BRANCH_SHA and $CURRENT_SHA are the same" >> $GITHUB_STEP_SUMMARY
            PARENT_COMMIT=$(git rev-parse $CURRENT_SHA^1)
            echo "PR merged to $BASE_BRANCH branch. Using parent commit $PARENT_COMMIT to find changes." >> $GITHUB_STEP_SUMMARY
            MODIFIED_FILES=$(git diff --name-only $PARENT_COMMIT $CURRENT_SHA)
          else
            # Regular diff
            MODIFIED_FILES=$(git diff --name-only origin/$BASE_BRANCH..$CURRENT_SHA)
          fi
          
          echo "Modified files: $MODIFIED_FILES"
          echo "$MODIFIED_FILES" | tr '\n' ',' > files_list.txt
          echo "MODIFIED_FILES=$(cat files_list.txt)" >> $GITHUB_ENV
          
          # Add modified files to the step summary
          echo "### Modified Files" >> $GITHUB_STEP_SUMMARY
          if [ -z "$MODIFIED_FILES" ]; then
            echo "No modified files" >> $GITHUB_STEP_SUMMARY
          else
            echo "$MODIFIED_FILES" >> $GITHUB_STEP_SUMMARY
          fi
        


      - name: Set program files and zip them
        id: set_programs
        run: |
          MODIFIED_FILES="${{ env.MODIFIED_FILES }}"
          ALPHA_FILES=()
          BETA_FILES=()
          GAMMA_FILES=()

          IFS=',' read -ra FILE_ARRAY <<< "$MODIFIED_FILES"
          for file in "${FILE_ARRAY[@]}"; do
            if [[ "$file" == alpha/* ]]; then
              ALPHA_FILES+=("$file")
            elif [[ "$file" == beta/* ]]; then
              BETA_FILES+=("$file")
            elif [[ "$file" == gamma/* ]]; then
              GAMMA_FILES+=("$file")
            fi
          done

          function zip_and_upload {
            PROGRAM_NAME=$1
            FILES=("${!2}")
            ZIP_NAME="${PROGRAM_NAME}_modified_files.zip"
            if [ ${#FILES[@]} -gt 0 ]; then
              zip -r "$ZIP_NAME" "${FILES[@]}"
              echo "Zipped $PROGRAM_NAME files into $ZIP_NAME"
              mv "$ZIP_NAME" "$PROGRAM_NAME.zip"
              echo "::set-output name=${PROGRAM_NAME}_exists::true"
            else
              echo "No modified files for $PROGRAM_NAME."
              echo "::set-output name=${PROGRAM_NAME}_exists::false"
            fi
          }

          zip_and_upload "alpha" ALPHA_FILES[@]
          zip_and_upload "beta" BETA_FILES[@]
          zip_and_upload "gamma" GAMMA_FILES[@]
      
      - name: Upload Alpha files
        if: steps.set_programs.outputs.alpha_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: alpha_modified_files
          path: alpha.zip
      - name: Upload Beta files
        if: steps.set_programs.outputs.beta_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: beta_modified_files
          path: beta.zip
      - name: Upload Gamma files
        if: steps.set_programs.outputs.gamma_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: gamma_modified_files
          path: gamma.zip     
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true)
    steps:
      - name: Download Alpha files
        if: needs.build.outputs.alpha_exists == 'true'
        uses: actions/download-artifact@v4
        with:
          name: alpha_modified_files
          path: downloaded_files/alpha
      - name: Download Beta files
        if: needs.build.outputs.beta_exists == 'true'
        uses: actions/download-artifact@v4
        with:
          name: beta_modified_files
          path: downloaded_files/beta
      - name: Download Gamma files
        if: needs.build.outputs.gamma_exists == 'true'
        uses: actions/download-artifact@v4
        with:
          name: gamma_modified_files
          path: downloaded_files/gamma
      - name: Extract and list downloaded files
        run: |
          echo "Listing downloaded files..."
          for program in alpha beta gamma; do
            if [ -d "downloaded_files/$program" ]; then
              echo "Contents of $program artifact:"
              ls "downloaded_files/$program"
            else
              echo "Artifact for $program does not exist."
            fi
          done

      - name: Deployment into ${{ env.ENVIRONMENT }} environment
        run: |
          echo "Deploying to the ${{ env.ENVIRONMENT }} environment..."